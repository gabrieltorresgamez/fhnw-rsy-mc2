---
title: "RSY: MC2"
subtitle: "Studiengang Data Science (HS2022), FHNW"
author: "Jan Zwicky und Gabriel Torres"
date: "Letzte Aktualisierungen: `r format(Sys.time(), '%B %d, %Y')`"
output:
  bookdown::html_document2:
      code_folding: show
      toc: true
      toc_depth: 3
      toc_float: true
      number_sections: true
editor_options: 
  chunk_output_type: console
---
<style>
#TOC {
  background-color: #F5F5F5;
  font-size: 16px;
}
#header{
  color: #708090;
  background-color: #F5F5F5;
  font-size: 30px;
}
body{
  color: #708090;
  background-color:#F5F5F5;
}
</style>

# Daten aufbereiten und Pakete Lesen
## Pakete laden und Daten einlesen
### Pakete laden
```{r setup, cache = TRUE, message = FALSE, warning = FALSE}
# Pakete für Data Wrangling und Visualisierung
library(tidyverse)

# Pakete für das HTML
library(bookdown)
library(knitr)

# Recommenderlab
library(recommenderlab)
```

###  Konfiguration der Pakete
```{r}
knitr::opts_chunk$set(fit.align = "left", cache = TRUE, warning = FALSE, message = FALSE)
set.seed(100)
```

### Daten einlesen und Samples erstellen
```{r}
movies <- read.csv("ml-latest-small/movies.csv", sep = ",")
links <- read.csv("ml-latest-small/links.csv", sep = ",")
ratings <- read.csv("ml-latest-small/ratings.csv", sep = ",")
tags <- read.csv("ml-latest-small/tags.csv", sep = ",")
```

## Vorbereitung der Daten
```{r}
norm_ratings <- ratings %>%
  group_by(userId) %>%
  summarise(mean_rating = mean(rating), sd_rating = sd(rating)) %>%
  right_join(., ratings, by = "userId")

norm_ratings$z_rating <- (norm_ratings$rating - norm_ratings$mean_rating) /
  norm_ratings$sd_rating

user_item <- norm_ratings %>%
  select(movieId, userId, z_rating) %>%
  pivot_wider(names_from = movieId, values_from = z_rating) %>%
  column_to_rownames(var = "userId")
```

# Aufgaben
## Erzeugung von Film- & Nutzerprofilen
### Binäre User-Liked-Items Matrix f̈ür alle Nutzer erzeugen.
```{r}
user_item_binary <- user_item > 0
```

### Dimension der User-Liked-Items Matrix prüfen und ausgeben.
```{r}
dim(user_item_binary)
```

### Movie-Genre Matrix für alle Filme erzeugen. 
```{r}
movie_genres <- as.matrix(movies %>%
  separate_rows(genres, sep = "\\|", convert = FALSE) %>%
  replace(. == "", "no genres listed") %>%
  mutate(value = TRUE) %>%
  select(movieId, genres, value) %>%
  pivot_wider(names_from = genres, values_from = value, values_fill = FALSE) %>%
  column_to_rownames("movieId"))
movies_genres_rated <- movie_genres[colnames(user_item_binary), ]
```

### Dimension der Movie-Genre Matrix prüfen und ausgeben.
#### All movies
```{r}
dim(movie_genres)
```

#### Only rated movies
```{r}
dim(movies_genres_rated)
```

### Anzahl unterschiedlicher Filmprofile bestimmen und visualisieren.
```{r}
movie_profile <- movie_genres %>%
  colSums() %>%
  as.list()
movie_profile <- tibble(genre = names(movie_profile), count = unname(unlist(movie_profile)))
```

```{r}
ggplot(movie_profile, aes(count, genre)) +
  geom_col()
```

### Alternativ mit Kombinationen
```{r}
movie_profile <- movies %>%
  group_by(genres) %>%
  summarise(Anzahl_Filme = n())

number_profile <- nrow(movie_profile)
sum_bottom <- movie_profile %>%
  arrange(Anzahl_Filme) %>%
  head(number_profile - 30) %>%
  summarise(genres = "combined", Anzahl_Filme = sum(Anzahl_Filme))

different_movies <- rbind(
  movie_profile %>%
    arrange(desc(Anzahl_Filme)) %>%
    head(30),
  sum_bottom
) %>%
  mutate(genres = fct_reorder(genres, Anzahl_Filme))

ggplot(different_movies, aes(Anzahl_Filme, factor(genres))) +
  geom_point()
```

### Nutzerprofile im Genre-Vektorraum erzeugen.
```{r}
# Variablen zur Berechnung
num_user <- dim(user_item_binary)[1]
num_genres <- dim(movie_genres)[2]
num_movies <- dim(user_item_binary)[2]

# Intitialisierung der Matrix
user_profiles <- matrix(0, num_user, num_genres)
colnames(user_profiles) <- colnames(movie_genres)
rownames(user_profiles) <- rownames(user_item_binary)

# Jeder User wird einzeln berechnet.
for (user_index in rownames(user_profiles)) {
  # User row wird gespeichert
  user <- user_item_binary[user_index, ]
  # Anzahl der Bewertungen wird gespeichert
  num_ratings <- sum(!is.na(user))
  # Array mit dem index der liked movies wird erstellt
  liked_movies <- names(user[which(user == T)])
  # Häufigkeit der Genre likes wird berechnet
  if (length(liked_movies) == 1) {
    user_profiles[user_index, ] <- movie_genres[liked_movies, ] / num_ratings
  } else {
    user_profiles[user_index, ] <- colSums(movie_genres[liked_movies, ]) / num_ratings
  }
}

# remove clutter
remove(liked_movies)
remove(num_ratings)
remove(num_genres)
remove(num_movies)
remove(user_index)
remove(num_user)
remove(user)
```

### Dimension der User-Genre-Profil Matrix prüfen und ausgeben.
```{r}
dim(user_profiles)
```

### Anzahl unterschiedlicher Nutzerprofile bestimmen, wenn Stärke der Genre-Kombination (a) vollständig (b) binär berücksichtigt wird.
```{r}
# (a) vollständig
print(paste("Unterschiedliche Nutzerprofile:", nrow(unique(user_profiles))))
# (b) binär (score = TRUE wenn score über (2 * durchschnitt) der scores des users liegt, sonst FALSE)
user_profiles_binary <- user_profiles > (2 * rowMeans(user_profiles))
print(paste("Unterschiedliche Binäre Nutzerprofile:", nrow(unique(user_profiles_binary))))
```

## Ähnlichkeit von Nutzern und Filmen
### Cosinus-Ähnlichkeit zwischen User-Genre- und Movie-Genre-Matrix berechnen.
```{r}
calc_cos_similarity_twomtrx <- function(m1, m2) {
  if (dim(m1)[2] != dim(m2)[2]) {
    return("Haram")
  }
  M1M2T <- m1 %*% t(m2)
  normM1 <- sqrt(rowSums(m1^2))
  normM2 <- sqrt(rowSums(m2^2))
  norms <- normM1 %*% t(normM2)
  return(M1M2T / norms)
}

similarity_users_movies <- calc_cos_similarity_twomtrx(movie_genres, user_profiles)
```

```{r}
#similarity_users <- as.matrix(similarity(as(user_profiles, "realRatingMatrix"), method = "cosine", which = "users"))
#diag(similarity_users) <- 1
#similarity_users[1:6,1:6]
```

```{r}
#similarity_movies <- as.matrix(similarity(as(movie_genres, "realRatingMatrix"), method = "jaccard", which = "users"))
#diag(similarity_movies) <- 1
#similarity_movies[1:6,1:6]
```

### Dimension der Matrix der Cosinus-Ähnlichkeiten von Nutzern und Filmen prüfen uns ausgeben
```{r}
#dim(similarity_users)
#dim(similarity_movies)
dim(similarity_users_movies)
```

### 5-Zahlen Statistik für Matrix der Cosinus-Ähnlichkeiten prüfen und ausgeben.
```{r}
#similarity_users %>% summary()
#similarity_movies %>% summary()
five_stats <- function(data) {
  print(paste("Min.:    ", min(data, na.rm = T)))
  print(paste("1st Qu.: ", quantile(data, probs = 1/4, na.rm = T)))
  print(paste("Median:  ", median(data, na.rm = T)))
  print(paste("Mean:    ", mean(data, na.rm = T)))
  print(paste("3rd Qu.: ", quantile(data, probs = 3/4, na.rm = T)))
  print(paste("Max.:    ", max(data, na.rm = T)))
  print(paste("NA's:    ", sum(is.na(data))))
}
```

```{r}
#five_stats(similarity_users)
#five_stats(similarity_movies)
five_stats(similarity_users_movies)
```

### Cosinus-Ähnlichkeiten von Nutzern und Filmen mit Dichteplot visualisieren.
```{r}
#density_similarity_users <- data.frame(x = as.vector(similarity_users))
#ggplot(density_similarity_users, aes(x)) + geom_density()

#density_similarity_movies <- data.frame(x = as.vector(similarity_movies))
#ggplot(density_similarity_movies, aes(x)) + geom_density()
```

```{r}
density_similarity <- data.frame(x = as.vector(similarity_users_movies))
ggplot(density_similarity, aes(x)) + geom_density()
```

### Cosinus-Ähnlichkeiten von Nutzern und Filmen mit Dichteplot für Nutzer “241”, “414”, “477”, “526”, “640” und “710” visualisieren.

Es gibt in unserem Datensatz nur 610 User, also können wir 640 und 710 nicht visualisieren
```{r}
ggplot() + 
  geom_density(aes(similarity_users_movies[,"241"]), color = "red") +
  geom_density(aes(similarity_users_movies[,"414"]), color = "blue") +
  geom_density(aes(similarity_users_movies[,"477"]), color = "darkgreen") +
  geom_density(aes(similarity_users_movies[,"526"]), color = "black") 

```
