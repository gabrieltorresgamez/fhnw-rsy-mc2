---
title: "RSY: MC2"
subtitle: "Studiengang Data Science (HS2022), FHNW"
author: "Jan Zwicky und Gabriel Torres"
date: "Letzte Aktualisierungen: `r format(Sys.time(), '%B %d, %Y')`"
output:
  bookdown::html_document2:
      code_folding: show
      toc: true
      toc_depth: 3
      toc_float: true
      number_sections: true
editor_options: 
  chunk_output_type: console
---
<style>
#TOC {
  background-color: #F5F5F5;
  font-size: 16px;
}
#header{
  color: #708090;
  background-color: #F5F5F5;
  font-size: 30px;
}
body{
  color: #708090;
  background-color:#F5F5F5;
}
</style>

# Daten aufbereiten und Pakete Lesen
## Pakete laden und Daten einlesen
### Pakete laden
```{r setup, cache = TRUE, message = FALSE, warning = FALSE}
# Pakete für Data Wrangling und Visualisierung
library(tidyverse)

# Pakete für das HTML
library(bookdown)
library(knitr)

# Recommenderlab
library(recommenderlab)
```

###  Konfiguration der Pakete
```{r}
knitr::opts_chunk$set(fit.align = "left", cache = TRUE, warning = FALSE, message = FALSE)
set.seed(100)
```

### Daten einlesen und Samples erstellen
```{r}
movies <- read.csv("ml-latest-small/movies.csv", sep = ",")
links <- read.csv("ml-latest-small/links.csv", sep = ",")
ratings <- read.csv("ml-latest-small/ratings.csv", sep = ",")
tags <- read.csv("ml-latest-small/tags.csv", sep = ",")
```

## Vorbereitung der Daten
```{r}
norm_ratings <- ratings %>%
  group_by(userId) %>%
  summarise(mean_rating = mean(rating), sd_rating = sd(rating)) %>%
  full_join(., ratings, by = "userId")

norm_ratings$z_rating <- (norm_ratings$rating - norm_ratings$mean_rating) /
  norm_ratings$sd_rating

users_items <- norm_ratings %>%
  select(movieId, userId, z_rating) %>%
  pivot_wider(names_from = movieId, values_from = z_rating) %>%
  column_to_rownames(var = "userId")

users_items <- users_items[, order(as.integer(colnames(users_items)))]
```

# Aufgaben
## Erzeugung von Film- & Nutzerprofilen
### Binäre User-Liked-Items Matrix f̈ür alle Nutzer erzeugen.
```{r}
users_items_binary <- users_items > 0
```

### Dimension der User-Liked-Items Matrix prüfen und ausgeben.
```{r}
dim(users_items_binary)
```

### Movie-Genre Matrix für alle Filme erzeugen. 
```{r}
movies_genres <- as.matrix(movies %>%
  separate_rows(genres, sep = "\\|", convert = FALSE) %>%
  replace(. == "", "no genres listed") %>%
  mutate(value = TRUE) %>%
  select(movieId, genres, value) %>%
  pivot_wider(names_from = genres, values_from = value, values_fill = FALSE) %>%
  column_to_rownames("movieId"))
movies_genres_rated <- movies_genres[colnames(users_items_binary), ]
```

### Dimension der Movie-Genre Matrix prüfen und ausgeben.
#### All movies
```{r}
dim(movies_genres)
```

#### Only rated movies
```{r}
dim(movies_genres_rated)
```

### Anzahl unterschiedlicher Filmprofile bestimmen und visualisieren.
```{r}
movies_profiles <- movies_genres %>%
  colSums() %>%
  as.list()
movies_profiles <- tibble(genre = names(movies_profiles), count = unname(unlist(movies_profiles)))
```

```{r}
ggplot(movies_profiles, aes(count, genre)) +
  geom_col()
```

### Alternativ mit Kombinationen
```{r}
movies_profiles_ <- movies %>%
  group_by(genres) %>%
  summarise(Anzahl_Filme = n())

number_profile <- nrow(movies_profiles_)
sum_bottom <- movies_profiles_ %>%
  arrange(Anzahl_Filme) %>%
  head(number_profile - 30) %>%
  summarise(genres = "combined", Anzahl_Filme = sum(Anzahl_Filme))

different_movies <- rbind(
  movies_profiles_ %>%
    arrange(desc(Anzahl_Filme)) %>%
    head(30),
  sum_bottom
) %>%
  mutate(genres = fct_reorder(genres, Anzahl_Filme))

ggplot(different_movies, aes(Anzahl_Filme, factor(genres))) +
  geom_point()
```

### Nutzerprofile im Genre-Vektorraum erzeugen.
```{r}
# Variablen zur Berechnung
num_user <- dim(users_items_binary)[1]
num_genres <- dim(movies_genres)[2]
num_movies <- dim(users_items_binary)[2]

# Intitialisierung der Matrix
users_profiles <- matrix(0, num_user, num_genres)
colnames(users_profiles) <- colnames(movies_genres)
rownames(users_profiles) <- rownames(users_items_binary)

# Jeder User wird einzeln berechnet.
for (users_index in rownames(users_profiles)) {
  # User row wird gespeichert
  user <- users_items_binary[users_index, ]
  # Anzahl der Bewertungen wird gespeichert
  num_ratings <- sum(!is.na(user))
  # Array mit dem index der liked movies wird erstellt
  liked_movies <- names(user[which(user == T)])
  # Häufigkeit der Genre likes wird berechnet
  if (length(liked_movies) == 1) {
    users_profiles[users_index, ] <- movies_genres[liked_movies, ] / num_ratings
  } else {
    users_profiles[users_index, ] <- colSums(movies_genres[liked_movies, ]) / num_ratings
  }
}

# remove clutter
remove(liked_movies)
remove(num_ratings)
remove(num_genres)
remove(num_movies)
remove(users_index)
remove(num_user)
remove(user)
```

### Dimension der User-Genre-Profil Matrix prüfen und ausgeben.
```{r}
dim(users_profiles)
```

### Anzahl unterschiedlicher Nutzerprofile bestimmen, wenn Stärke der Genre-Kombination (a) vollständig (b) binär berücksichtigt wird.
```{r}
# (a) vollständig
print(paste("Unterschiedliche Nutzerprofile:", nrow(unique(users_profiles))))
# (b) binär (score = TRUE wenn score über (2 * durchschnitt) der scores des users liegt, sonst FALSE)
users_profiles_binary <- users_profiles > (2 * rowMeans(users_profiles))
print(paste("Unterschiedliche Binäre Nutzerprofile:", nrow(unique(users_profiles_binary))))
```

## Ähnlichkeit von Nutzern und Filmen
### Cosinus-Ähnlichkeit zwischen User-Genre- und Movie-Genre-Matrix berechnen.
```{r}
calc_cos_similarity_twomtrx <- function(m1, m2) {
  if (dim(m1)[2] != dim(m2)[2]) {
    return("Haram")
  }
  M1M2T <- m1 %*% t(m2)
  normM1 <- sqrt(rowSums(m1^2))
  normM2 <- sqrt(rowSums(m2^2))
  norms <- normM1 %*% t(normM2)
  return(M1M2T / norms)
}

similarity_users_movies <- calc_cos_similarity_twomtrx(movies_genres, users_profiles)
```

### Dimension der Matrix der Cosinus-Ähnlichkeiten von Nutzern und Filmen prüfen uns ausgeben
```{r}
dim(similarity_users_movies)
```

### 5-Zahlen Statistik für Matrix der Cosinus-Ähnlichkeiten prüfen und ausgeben.
```{r}
five_stats <- function(data) {
  print(paste("Min.:    ", min(data, na.rm = T)))
  print(paste("1st Qu.: ", quantile(data, probs = 1 / 4, na.rm = T)))
  print(paste("Median:  ", median(data, na.rm = T)))
  print(paste("Mean:    ", mean(data, na.rm = T)))
  print(paste("3rd Qu.: ", quantile(data, probs = 3 / 4, na.rm = T)))
  print(paste("Max.:    ", max(data, na.rm = T)))
  print(paste("NA's:    ", sum(is.na(data))))
}

five_stats(similarity_users_movies)
```

### Cosinus-Ähnlichkeiten von Nutzern und Filmen mit Dichteplot visualisieren.
```{r}
density_similarity <- data.frame(x = as.vector(similarity_users_movies))
ggplot(density_similarity, aes(x)) +
  geom_density()
```

### Cosinus-Ähnlichkeiten von Nutzern und Filmen mit Dichteplot für Nutzer “241”, “414”, “477”, “526”, “640” und “710” visualisieren.
Es gibt in unserem Datensatz nur 610 User, also können wir 640 und 710 nicht visualisieren
```{r}
ggplot() +
  geom_density(aes(similarity_users_movies[, "241"]), color = "red") +
  geom_density(aes(similarity_users_movies[, "414"]), color = "blue") +
  geom_density(aes(similarity_users_movies[, "477"]), color = "darkgreen") +
  geom_density(aes(similarity_users_movies[, "526"]), color = "black")
```

## Empfehlbare Filme
### Bewertete Filme maskieren, d.h. “Negativabzug” der User-Items Matrix erzeugen, um anschliessend Empfehlungen herzuleiten.
```{r}
neg_deduction <- is.na(users_items) * 1
```

### Zeilensumme des “Negativabzuges” der User-Items Matrix für die User “5”, “25”, “50” und “150” ausgeben.
```{r}
rowSums(neg_deduction)[c(5, 25, 50, 150)]
```

### 5-Zahlen Statistik der Zeilensumme des “Negativabzuges” der User-Items Matrix bestimmen.
```{r}
five_stats(neg_deduction)
```

## Top-N Empfehlungen
### Matrix für Bewertung aller Filme durch element-weise Multiplikation der Matrix der Cosinus-Ähnlichkeiten von Nutzern und Filmen und “Negativabzug” der User-Items Matrix erzeugen.
```{r}
# make sure matrix has same dimensions and same order
users_number <- colnames(similarity_users_movies)
diff <- setdiff(similarity_users_movies %>% rownames(), setdiff(similarity_users_movies %>% rownames(), neg_deduction %>% colnames()))
similarity_users_movies <- similarity_users_movies[diff, users_number]
neg_deduction <- neg_deduction[users_number, diff]

# Elementwise multiplication
recommendations <- neg_deduction * t(similarity_users_movies)
recommendations[1:6, 1:6]
```

### Dimension der Matrix für die Bewertung aller Filme prüfen.
```{r}
dim(recommendations)
```

### Top-20 Listen extrahieren und Länge der Listen pro Nutzer prüfen.
```{r}
get_top_n_id <- function(n, recommendations) {
  top_n <- matrix(0, dim(recommendations), n)
  for (user_id in rownames(recommendations)) {
    top_n[as.numeric(user_id), ] <- names(sort(recommendations[user_id, ], decreasing = TRUE)[1:n])
  }
  return(top_n)
}

get_top_n_sim <- function(n, recommendations) {
  top_n <- matrix(0, dim(recommendations), n)
  for (user_id in rownames(recommendations)) {
    top_n[as.numeric(user_id), ] <- sort(recommendations[user_id, ], decreasing = TRUE)[1:n]
  }
  return(top_n)
}

top20 <- get_top_n_id(20, recommendations) # rows = user, cols = top n movie id
top20[1:6, 1:6]
```

### Verteilung der minimalen Ähnlichkeit für Top-N Listen für N = 10, 20, 50, 100 für alle Nutzer visuell vergleichen.
```{r}
min_sim_n10 <- data_frame(x = get_top_n_sim(10, recommendations)[, 10])
min_sim_n20 <- data_frame(x = get_top_n_sim(20, recommendations)[, 20])
min_sim_n50 <- data_frame(x = get_top_n_sim(50, recommendations)[, 50])
min_sim_n100 <- data_frame(x = get_top_n_sim(100, recommendations)[, 100])

ggplot(min_sim_n10, aes(x)) +
  geom_histogram(binwidth = 0.005, na.rm = TRUE) +
  xlim(0, 1) +
  ylim(0, 35)

ggplot(min_sim_n20, aes(x)) +
  geom_histogram(binwidth = 0.005, na.rm = TRUE) +
  xlim(0, 1) +
  ylim(0, 35)

ggplot(min_sim_n50, aes(x)) +
  geom_histogram(binwidth = 0.005, na.rm = TRUE) +
  xlim(0, 1) +
  ylim(0, 35)

ggplot(min_sim_n100, aes(x)) +
  geom_histogram(binwidth = 0.005, na.rm = TRUE) +
  xlim(0, 1) +
  ylim(0, 35)
```

### Top-20 Empfehlungen für Nutzer “5”, “25”, “50”, “150” visualisieren.
```{r}
# number of recommendations
top20[c(5, 25, 50, 150),]

```

### Für Nutzer “133” und “555” Profil mit Top-N Empfehlungen für N = 20, 30, 40, 50 analysieren, visualisieren und diskutieren.
```{r}
# cleveland plot
```
